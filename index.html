<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>俄罗斯方块</title>
<style>
*{box-sizing:border-box;margin:0;padding:0;}
html,body{height:100%;width:100%;font-family:sans-serif;background:#ffebcc;color:#222;user-select:none;touch-action:none;overflow:hidden;}
#main{display:flex;height:100%;width:100%;}
#left{width:30%;padding:8px;display:flex;flex-direction:column;gap:8px;}
.panel{background:#ffe4a3;border-radius:12px;padding:8px;flex-shrink:0;box-shadow:0 0 8px rgba(0,0,0,0.2);}
h3{margin:4px 0;font-size:14px;text-align:center;color:#333;}
#gameWrap{width:100%;height:100%;display:flex;justify-content:center;align-items:center;}
canvas{background:#fff8e7;border-radius:12px;display:block;width:100%;height:auto;}
#level,button{width:100%;padding:6px;margin:3px 0;border-radius:8px;border:none;font-size:14px;background:#ffd966;color:#333;cursor:pointer;}
#level option{background:#fff;}
#instructions{position:absolute;bottom:0;width:100%;background:rgba(255,235,204,0.9);padding:6px;text-align:center;font-size:12px;line-height:1.4;color:#333;box-shadow:0 -2px 6px rgba(0,0,0,0.2);}
</style>
</head>
<body>
<div id="main">
  <div id="left">
    <div class="panel"><h3>排行榜</h3><div id="rank">暂无</div></div>
    <div class="panel"><h3>下一个方块</h3><canvas id="next" width="80" height="80"></canvas></div>
    <div class="panel">
      <select id="level">
        <option value="800">简单</option>
        <option value="500" selected>普通</option>
        <option value="300">困难</option>
      </select>
      <button id="start">开始</button>
      <button id="pause">暂停</button>
    </div>
  </div>
  <div id="right">
    <div id="gameWrap">
      <canvas id="game" width="300" height="600"></canvas>
    </div>
  </div>
</div>
<div id="instructions">
操作说明：PC键盘：← → 移动，↓软下落，上旋转 | 手机滑动：左右滑动→移动（支持连续），上滑→旋转，下滑→软下落
</div>

<script>
// ==================== 参数 ====================
const COLS=10,ROWS=20,BLOCK=30;
const canvas=document.getElementById("game"),ctx=canvas.getContext("2d");
const nextC=document.getElementById("next"),nctx=nextC.getContext("2d");
let board=[],cur,next,bag=[],state="idle",score=0,combo=0,dropInterval=500,dropTimer=0,lockTimer=0,LOCK_DELAY=500,lastTime=0;
const SHAPES={I:[[1,1,1,1]],O:[[1,1],[1,1]],T:[[0,1,0],[1,1,1]],S:[[0,1,1],[1,1,0]],Z:[[1,1,0],[0,1,1]],J:[[1,0,0],[1,1,1]],L:[[0,0,1],[1,1,1]]};
const COLORS={I:"#4df",O:"#ffd700",T:"#d5f",S:"#4f4",Z:"#f44",J:"#44f",L:"#fa4"};

// ==================== 7-Bag ====================
function newBag(){ bag=Object.keys(SHAPES).sort(()=>Math.random()-0.5);}
function getNext(){ if(!bag.length)newBag(); const k=bag.pop(); return {k,shape:SHAPES[k],x:3,y:0,rot:0};}

// ==================== 初始化 ====================
function reset(){
 board=Array.from({length:ROWS},()=>Array(COLS).fill(0));
 score=0;combo=0;
 cur=getNext(); next=getNext();
 dropTimer=0;lockTimer=0; tSpin=false;
 state="playing";
 DAS_L=ARR_L=DAS_R=ARR_R=0;
 updateRank();
}

// ==================== 碰撞检测 ====================
function canMove(x,y,shape){
 for(let r=0;r<shape.length;r++)
  for(let c=0;c<shape[r].length;c++)
   if(shape[r][c]){
    let nx=x+c,ny=y+r;
    if(nx<0||nx>=COLS||ny>=ROWS) return false;
    if(ny>=0 && board[ny][nx]) return false;
   }
 return true;
}

// ==================== SRS Wall Kick ====================
const WALL_KICKS={
 I:[[[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    [[0,0],[1,0],[-2,0],[1,-2],[-2,1]]],
 JLSTZ:[[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
        [[0,0],[1,0],[1,-1],[0,2],[1,2]],
        [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
        [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]]]
};

function rotate(){
 const oldShape=cur.shape;
 const r=oldShape[0].map((_,i)=>oldShape.map(row=>row[i]).reverse());
 const kicks=(cur.k==="I")?WALL_KICKS.I:WALL_KICKS.JLSTZ;
 for(let k of kicks[cur.rot]){
   if(canMove(cur.x+k[0],cur.y+k[1],r)){
     cur.x+=k[0]; cur.y+=k[1]; cur.shape=r;
     cur.rot=(cur.rot+1)%4; lockTimer=0;
     checkTSpin(); return;
   }
 }
}

// ==================== T-Spin 判定 ====================
let tSpin=false;
function checkTSpin(){
 if(cur.k!=="T") { tSpin=false; return; }
 let corners=[[0,0],[2,0],[0,2],[2,2]],count=0;
 for(let [dx,dy] of corners){
   let x=cur.x+dx,y=cur.y+dy;
   if(x<0||x>=COLS||y<0||y>=ROWS||board[y][x]) count++;
 }
 tSpin=(count>=3);
}

// ==================== 主循环 ====================
let inputState={left:false,right:false,down:false,up:false};
let DAS_L=0,ARR_L=0,DAS_R=0,ARR_R=0;
const DAS=170,ARR=50;
function loop(t){
 if(state!=="playing"){lastTime=t;requestAnimationFrame(loop);return;}
 let dt=t-lastTime;lastTime=t;
 dropTimer+=dt;

 // 左右移动 DAS/ARR
 if(inputState.left){ DAS_L+=dt; if(DAS_L>=DAS){ARR_L+=dt; while(ARR_L>=ARR){move(-1);ARR_L-=ARR;}} }else{DAS_L=0;ARR_L=0;}
 if(inputState.right){ DAS_R+=dt; if(DAS_R>=DAS){ARR_R+=dt; while(ARR_R>=ARR){move(1);ARR_R-=ARR;}} }else{DAS_R=0;ARR_R=0;}
 // 下落
 if(inputState.down){softDrop();}
 // 向上旋转
 if(inputState.up){rotate();inputState.up=false;}

 if(dropTimer>=dropInterval){
   if(canMove(cur.x,cur.y+1,cur.shape)){cur.y++;lockTimer=0;}else{lockTimer+=dropTimer;if(lockTimer>=LOCK_DELAY) lock();}
   dropTimer=0;
 }

 draw();
 requestAnimationFrame(loop);
}

// ==================== 锁定 ====================
function lock(){
 cur.shape.forEach((r,y)=>r.forEach((v,x)=>{if(v && cur.y+y>=0) board[cur.y+y][cur.x+x]=cur.k;}));
 clearLines();
 cur=next; next=getNext(); cur.rot=0; lockTimer=0; DAS_L=ARR_L=DAS_R=ARR_R=0; tSpin=false;
 if(!canMove(cur.x,cur.y,cur.shape)) state="gameover";
}

// ==================== 消行 ====================
function clearLines(){
 let lines=0;
 board=board.filter(r=>{if(r.every(v=>v)){lines++;return false;} return true;});
 while(board.length<ROWS) board.unshift(Array(COLS).fill(0));
 if(lines>0){combo++;score+=lines*100*combo; if(tSpin) score+=400;} else combo=0;
 updateRank();
}

// ==================== 绘制 ====================
function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 board.forEach((r,y)=>r.forEach((v,x)=>{if(v){ctx.fillStyle=COLORS[v];ctx.fillRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);}}));
 drawGhost(); drawPiece(cur); drawNext();
}
function drawPiece(p){ctx.fillStyle=COLORS[p.k];p.shape.forEach((r,y)=>r.forEach((v,x)=>{if(v)ctx.fillRect((p.x+x)*BLOCK,(p.y+y)*BLOCK,BLOCK,BLOCK);}))}
function drawGhost(){let y=cur.y;while(canMove(cur.x,y+1,cur.shape))y++;ctx.globalAlpha=0.3;drawPiece({...cur,y});ctx.globalAlpha=1;}

// ==================== 下一个方块预览 ====================
function drawNext(){
    nctx.clearRect(0,0,nextC.width,nextC.height);
    const shape = next.shape;
    const rows = shape.length;
    const cols = shape[0].length;
    const scale = Math.min(nextC.width/cols, nextC.height/rows);
    const offsetX = (nextC.width - cols*scale)/2;
    const offsetY = (nextC.height - rows*scale)/2;
    shape.forEach((r,y)=>{
        r.forEach((v,x)=>{
            if(v){
                nctx.fillStyle = COLORS[next.k];
                nctx.fillRect(offsetX + x*scale, offsetY + y*scale, scale, scale);
            }
        })
    })
}

// ==================== 移动 ====================
function move(dx){if(canMove(cur.x+dx,cur.y,cur.shape)){cur.x+=dx;lockTimer=0;}}

// ==================== 软下落 ====================
function softDrop(){if(canMove(cur.x,cur.y+1,cur.shape)){cur.y++;score++;}}

// ==================== 按钮 ====================
document.getElementById("start").onclick=()=>{dropInterval=+document.getElementById("level").value;reset();}
document.getElementById("pause").onclick=()=>{state=state==="playing"?"paused":"playing";}

// ==================== 键盘输入 ====================
document.addEventListener("keydown",e=>{
 e.preventDefault();
 if(e.key==="ArrowLeft") inputState.left=true;
 if(e.key==="ArrowRight") inputState.right=true;
 if(e.key==="ArrowDown") inputState.down=true;
 if(e.key==="ArrowUp") inputState.up=true;
});
document.addEventListener("keyup",e=>{
 if(e.key==="ArrowLeft") inputState.left=false;
 if(e.key==="ArrowRight") inputState.right=false;
 if(e.key==="ArrowDown") inputState.down=false;
 if(e.key==="ArrowUp") inputState.up=false;
});

// ==================== Canvas 内滑动 DAS/ARR ====================
let startX=0,startY=0,holdDir=null;
let holdTimer=0,holdARRTimer=0;
canvas.addEventListener("touchstart",e=>{
 const t=e.touches[0]; startX=t.clientX; startY=t.clientY;
 holdDir=null; holdTimer=0; holdARRTimer=0;
},{passive:false});

canvas.addEventListener("touchmove",e=>{
 e.preventDefault();
 const t=e.touches[0];
 let dx=t.clientX-startX, dy=t.clientY-startY;

 // 左右滑动 DAS/ARR
 if(Math.abs(dx)>BLOCK){
   holdDir = dx>0 ? "right":"left";
   startX = t.clientX;
   holdTimer = DAS; holdARRTimer = ARR; // 立即触发一次
   if(holdDir==="left") move(-1); else move(1);
 }

 // 上滑旋转
 if(dy<-BLOCK){rotate(); startY=t.clientY;}
 // 下滑软下落
 if(dy>BLOCK){softDrop(); startY=t.clientY;}
},{passive:false});

canvas.addEventListener("touchend",e=>{
 holdDir=null; holdTimer=0; holdARRTimer=0;
 inputState.down=false; inputState.up=false;
},{passive:false});

// 连续移动循环
function touchLoop(dt){
 if(holdDir){
   holdTimer += dt;
   holdARRTimer += dt;
   if(holdTimer>=DAS){
     while(holdARRTimer>=ARR){if(holdDir==="left") move(-1); else move(1); holdARRTimer-=ARR;}
   }
 }
 requestAnimationFrame(touchLoop);
}
requestAnimationFrame(touchLoop);

// ==================== 排行榜 ====================
function updateRank(){document.getElementById("rank").innerText="分数:"+score+"  连击:"+combo+(tSpin?"  T-Spin":"");}

// ==================== 开始循环 ====================
requestAnimationFrame(function loopStart(t){lastTime=t;loop(t);});
</script>
</body>
</html>
